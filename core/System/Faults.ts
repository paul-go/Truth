
namespace Truth
{
	/**
	 * A type that describes the possible objects within a document
	 * that may be responsible for the generation of a fault.
	 */
	export type TFaultSource = Statement | Span | InfixSpan;
	
	/** @internal */
	export type StatementFault = Readonly<Fault<Statement>>;
	
	/** @internal */
	export type StatementFaultType = Readonly<FaultType<Statement>>;
	
	/** @internal */
	export type SpanFault = Readonly<Fault<Span>>;
	
	/** @internal */
	export type SpanFaultType = Readonly<FaultType<Span | InfixSpan>>;
	
	/**
	 * A class that represents a fault generated by the system.
	 * In some systems, this may be referred to as a "diagnostic".
	 */
	export class Fault<TSource = TFaultSource>
	{
		constructor(
			/** */
			readonly type: FaultType<TSource>,
			
			/** The document object that caused the fault to be reported. */
			readonly source: TSource,
			
			/**
			 * A human-readable message that contains more in-depth detail
			 * of the fault that occured, in addition to the standard message.
			 */
			readonly additionalDetail: string = "")
		{
			const src = this.source;
			
			// The +1's are necessary in order to deal with the fact that
			// most editors are 1-based whereas the internal representation
			// of statement strings are 0-based.
			
			if (src instanceof Statement)
			{
				// The TabsAndSpaces fault is the only fault that needs a
				// special case where it has a different reporting location.
				this.range = type.code === Faults.TabsAndSpaces.code ?
					{ start: 1, end: src.indent + 1 } :
					{ start: src.indent + 1, end: src.sourceText.length + 1 };
			}
			else if (src instanceof Span || src instanceof InfixSpan)
			{
				this.range = {
					// This is +1 to account for the difference between the
					// 0-based internal format and the 1-based external format
					start: src.boundary.offsetStart + 1,
					// This is +2 to account for the 0-based and 1-based difference,
					// and also the fact that this is an "end column" rather than
					// an ending character position.
					end: src.boundary.offsetEnd + 2
				};
			}
			else throw Exception.unknownState();
		}
		
		/**
		 * Converts this fault into a string representation,
		 * suitable for output as an error message.
		 */
		toString()
		{
			const doc = this.document;
			
			const avoidProtocols = [
				UriProtocol.memory,
				UriProtocol.none,
				UriProtocol.unknown
			];
			
			const uriText = avoidProtocols.includes(doc.uri.protocol) ?
				"" : doc.uri.toString() + " ";
			
			const colNums = this.range.start + "-" + this.range.end;
			const colText = colNums ? ", Col " + colNums : "";
			
			return `${this.type.message} (${uriText}Line ${this.line}${colText})`;
		}
		
		/**
		 * Gets a reference to the Document in which this Fault was detected.
		 */
		get document()
		{
			return this.statement.document;
		}
		
		/**
		 * Gets a reference to the Statement in which this Fault was detected.
		 */
		get statement()
		{
			const src = this.source;
			return Not.null(
				src instanceof Statement ? src :
				src instanceof Span ? src.statement :
				src instanceof InfixSpan ? src.statement :
				null);
		}
		
		/**
		 * Gets the 1-based line number of the Statement in which this Fault was detected.
		 */
		get line()
		{
			return this.statement.line;
		}
		
		/**
		 * Gets an array representing the starting and ending character offsets
		 * within the Statement in which this Fault was detected. The character
		 * offsets are 1-based (not 0-based) to comply with the behaviour of 
		 * most text editors.
		 */
		readonly range: { start: number, end: number; };
	}
	
	/**
	 * 
	 */
	export class FaultType<TSource = TFaultSource>
	{
		constructor(
			/**
			 * An error code, useful for reference purposes, or display in a user interface.
			 */
			readonly code: number,
			/**
			 * A human-readable description of the fault.
			 */
			readonly message: string,
			/**
			 * 
			 */
			readonly severity: FaultSeverity)
		{
			this.message = message.trim().replace(/\s\s+/g, " ");
		}
		
		/**
		 * Creates a fault of this type.
		 */
		create(source: TSource)
		{
			return new Fault<TSource>(this, source);
		}
	}
	
	/**
	 * The following definitions are intentionally equivalent
	 * to the severity codes from the monaco editor.
	 */
	export const enum FaultSeverity
	{
		/** Unused. */
		hint = 1,
		
		/** Unused. */
		info = 2,
		
		/**
		 * Indicates the severity of a fault is "warning", which means that
		 * the associated object will still be processed during fact checking.
		 */
		warning = 4,
		
		/**
		 * Indicates the severity of a fault is "error", which means that
		 * the associated object will be ignored during fact checking.
		 */
		error = 8
	}
	
	/**
	 * Utility function for creating frozen fault instances.
	 */
	function createFault<T>(
		code: number,
		message: string,
		severity = FaultSeverity.error)
	{
		return Object.freeze(new FaultType<T>(code, message, severity));
	}
	
	const quantifiers = 
		`(${RegexSyntaxMisc.star}, 
		${RegexSyntaxMisc.plus},
		${RegexSyntaxDelimiter.quantifierStart}..${RegexSyntaxDelimiter.quantifierEnd})`;
	
	/**
	 * 
	 */
	export const Faults = Object.freeze({
		
		/** */
		*each()
		{
			const values = Object.values(Faults) as FaultType<object>[];
			
			for (const faultType of values)
				if (faultType instanceof FaultType)
					yield faultType;
		},
		
		/**
		 * @returns An object containing the FaultType instance
		 * associated with the fault with the specified code, as
		 * well as the name of the instance. In the case when the
		 * faultCode was not found, null is returned.
		 */
		nameOf(faultCode: number)
		{
			const entries = Object.entries(Faults) as [string, FaultType<object>][];
			
			for (const [name, faultType] of entries)
				if (faultType instanceof FaultType)
					if (faultType.code === faultCode)
						return name;
			
			return "";
		},
		
		//# Resource-Related Faults
		
		/** */
		UnresolvedResource: createFault<Statement>(
			100,
			"URI points to a resource that could not be resolved."),
		
		/** */
		CircularResourceReference: createFault<Statement>(
			102,
			"URI points to a resource that would cause a circular reference."),
		
		/** */
		InsecureResourceReference: createFault<Statement>(
			104,
			`Documents loaded from remote locations
			cannot reference documents stored locally.`),
		
		/** */
		DuplicateReference: createFault<Statement>(
			106,
			"Document has already been referenced.",
			FaultSeverity.error),
		
		//# Fact Checking Faults
		
		/** */
		UnresolvedAnnotation: createFault<Span>(
			201,
			"Unresolved annotation."),
		
		/** */
		CircularFactReference: createFault<Span>(
			203,
			"Circular fact reference detected."),
		
		/** */
		ContractViolation: createFault<Statement>(
			//! CHANGE THIS TO 204
			205,
			"Overridden facts must explicitly expand the fact as defined in the base."),
		
		/** */
		UnexpectedHomograph: createFault<Statement>(
			206,
			`Homographs may only be defined at the surface level of a document.`),
		
		/** */
		IgnoredAnnotation: createFault<Span>(
			207,
			`This annotation is ignored because another annotation
			in this statement resolves to the same fact.`),
		
		/** */
		IgnoredAlias: createFault<Span>(
			209,
			`Aliases (meaning annotations that are matched by patterns)
			can't be added onto facts that have a contract put in place
			by a base fact.`),
		
		/** */
		FactSelfReferential: createFault<Span>(
			211,
			"Facts cannot be self-referential"),
		
		//# List-related faults
		
		/** */
		AnonymousInListIntrinsic: createFault<Statement>(
			300,
			"Facts contained directly by List-intrinsic facts cannot be anonymous.",
			FaultSeverity.warning),
		
		/** */
		ListContractViolation: createFault<Span>(
			301,
			"The containing list cannot contain children of this fact.",
			FaultSeverity.warning),
		
		/** */
		ListIntrinsicExtendingList: createFault<Span>(
			303,
			"List intrinsic facts cannot extend from other lists."),
		
		/** (This is the same thing as a list dimensionality conflict) */
		ListExtrinsicExtendingNonList: createFault<Span>(
			305,
			"Lists cannot extend from non-lists."),
		
		/** */
		ListDimensionalDiscrepancyFault: createFault<Span>(
			307,
			`A union cannot be created between these two facts
			because they are lists of different dimensions.`),
		
		/** */
		ListAnnotationConflict: createFault<Span>(
			309,
			`All fragments of this annotation need to have
			a list operator (${Syntax.list})`),
		
		//# Pattern-related faults
		
		/** */
		PatternInvalid: createFault<Statement>(
			400,
			"Invalid pattern."),
		
		/** */
		PatternWithoutAnnotation: createFault<Statement>(
			402,
			"Pattern has no annotations.",
			FaultSeverity.warning),
		
		/** */
		PatternCanMatchEmpty: createFault<Statement>(
			404,
			"Patterns must not be able to match an empty input."),
		
		/** */
		PatternMatchingFactsAlreadyExists: createFault<Statement>(
			406,
			`A pattern matching these facts has 
			already been defined in this scope.`),
		
		/** */
		PatternMatchingList: createFault<Span>(
			407,
			"A pattern cannot match a list fact."),
		
		/** */
		PatternCanMatchWhitespaceOnly: createFault<Statement>(
			420,
			"Patterns must not be able to match an input " +
			"containing only whitespace characters."),
		
		/** */
		PatternAcceptsLeadingWhitespace: createFault<Statement>(
			422,
			"Patterns must not be able to match an input " +
			"containing only whitespace characters."),
		
		/** */
		PatternRequiresLeadingWhitespace: createFault<Statement>(
			424,
			"Patterns must not be able to match an input " +
			"containing only whitespace characters."),
		
		/** */
		PatternAcceptsTrailingWhitespace: createFault<Statement>(
			426,
			"Patterns must not be able to match an input " +
			"containing only whitespace characters."),
		
		/** */
		PatternRequiresTrailingWhitespace: createFault<Statement>(
			428,
			"Patterns must not be able to match an input " +
			"containing only whitespace characters."),
		
		/** */
		PatternNonCovariant: createFault<Statement>(
			440,
			"Pattern does not match it's base facts."),
		
		/** */
		PatternPartialWithCombinator: createFault<Statement>(
			442,
			"Partial patterns cannot explicitly match the comma character."),
		
		/** */
		PatternsFormDiscrepantUnion: createFault<Span>(
			499,
			"A union cannot be created between these facts because their " + 
			"associated patterns conflict with each other."),
		
		//# Infix related
		
		/** */
		InfixHasQuantifier: createFault<Statement>(
			///0,
			500,
			`Infixes cannot have quantifiers ${quantifiers} applied to them`),
		
		/** */
		InfixHasDuplicateTerm: createFault<InfixSpan>(
			///0,
			501,
			"Infixes cannot have duplicate terms."),
		
		/** */
		InfixHasSelfReferentialFact: createFault<InfixSpan>(
			///410,
			503,
			"Infixes cannot be self-referential."),
		
		/** */
		InfixNonConvariant: createFault<InfixSpan>(
			///412,
			505,
			"Infixes must be compatible with their bases."),
		
		/** */
		InfixCannotDefineNewFacts: createFault<InfixSpan>(
			///422,
			507,
			`A fact referenced in an infix must be contained
			by the pattern statement directly, or be contained
			by one of it's matched bases.`),
		
		/** */
		InfixReferencedFactMustHavePattern: createFault<InfixSpan>(
			///414,
			509,
			"Facts applied to an infix must have at least one associated pattern."),
		
		/** */
		InfixReferencedFactCannotBeRecursive: createFault<InfixSpan>(
			///416,
			511,
			"Facts applied to an infix must not create a recursive structure."),
		
		/** */
		InfixContractViolation: createFault<InfixSpan>(
			///424,
			513,
			"Infix fact annotations must explicitly expand the fact as defined by the base."),
		
		/** */
		InfixPopulationChaining: createFault<InfixSpan>(
			///426,
			515,
			"Population infixes cannot have multiple declarations."),
		
		/** */
		InfixUsingListOperator: createFault<InfixSpan>(
			///0,
			517,
			`Infix terms cannot end with the list operator (${Syntax.list}).`),
		
		/** */
		InfixReferencingList: createFault<InfixSpan>(
			///428,
			519,
			"Infixes cannot reference list facts."),
		
		/** */
		PortabilityInfixHasMultipleDefinitions: createFault<InfixSpan>(
			///418,
			521,
			`Portability infixes with compatible facts cannot
			be specified more than once.`),
		
		/** */
		PortabilityInfixHasUnion: createFault<InfixSpan>(
			///418,
			523,
			"Portability infixes with unioned facts are not supported at this time."),
		
		/** */
		PopulationInfixHasMultipleDefinitions: createFault<InfixSpan>(
			///0,
			525,
			`Declarations in a population infix cannot be 
			defined twice in the same pattern`),
		
		/** */
		NominalInfixMustBeSub: createFault<Span>(
			///430,
			527,
			"Patterns with nominal infixes require an input that is " +
			"derived from the fact specified, not the fact itself."),
		
		/** */
		NthLevelHomograph: createFault<Span>(
			601,
			"Homographs may not be defined beyond the first level."),
		
		//# Parse errors
		
		/** */
		StatementBeginsWithComma: createFault<Statement>(
			600,
			"Statements cannot begin with a comma."),
		
		/** */
		StatementBeginsWithEllipsis: createFault<Statement>(
			602,
			"Statements cannot begin with an ellipsis (...)."),
		
		/** */
		StatementBeginsWithEscapedSpace: createFault<Statement>(
			604,
			"Statements cannot begin with an escape character (\\) " + 
			"that is followed by a tab or space."),
		
		/** */
		StatementContainsOnlyEscapeCharacter: createFault<Statement>(
			606,
			"A statement cannot consist of a single escape character (\\)"),
		
		/** */
		StatementBeginsWithInvalidSequence: createFault<Statement>(
			608,
			"A statement cannot begin with the sequences: /*, /+, or /?"),
		
		//# Parsing Faults
		
		/** */
		TabsAndSpaces: createFault<Statement>(
			1000,
			"Statement indent contains a mixture of tabs and spaces.",
			FaultSeverity.warning),
		
		/** */
		DuplicateDeclaration: createFault<Span>(
			1001,
			"Duplicated declaration."),
		
		/** */
		UnterminatedCharacterSet: createFault<Statement>(
			1002,
			`Unterminated character set. Pattern has an opening
			"${RegexSyntaxDelimiter.setStart}" character without a matching
			"${RegexSyntaxDelimiter.setEnd}" character.`),
		
		/** */
		UnterminatedGroup: createFault<Statement>(
			1004,
			`Unterminated group. Pattern has an opening
			"${RegexSyntaxDelimiter.groupStart}" character without a matching
			"${RegexSyntaxDelimiter.groupEnd}" character.`),
		
		/** */
		DuplicateQuantifier: createFault<Statement>(
			1006,
			`Multiple consecutive quantifiers ${quantifiers} are not allowed.`),
		
		/** */
		UnterminatedInfix: createFault<Statement>(
			1008,
			`Unterminated infix. Pattern has an opening ${InfixSyntax.start},
			${InfixSyntax.nominalStart}, ${InfixSyntax.patternStart} delimiter without
			a matching closing delimiter.`),
		
		/** */
		EmptyPattern: createFault<Statement>(
			1010,
			"Pattern has no matchable content.")
	});
	
	// Additional safety
	Array.from(Faults.each()).every(Object.freeze);
}
